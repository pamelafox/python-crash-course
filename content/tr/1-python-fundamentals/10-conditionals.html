<p dir="ltr">Artık Boole ifadelerinin nasıl yazılacağını bildiğimize göre, programlarımıza koşullu <italic>olarak</italic> bir kod bloğunu diğerine karşı yürütmelerini söylemek için bunları <bold>koşullu ifadeler</bold> içinde kullanabiliriz.</p>
<h3 dir="ltr">Koşullu ifadeler</h3>
<p dir="ltr">Python'da koşullu ifadeler her zaman <code>if</code>. Temel şablon aşağıda verilmiştir:</p>
<pre dir="ltr"><code><condition>:
    <statement>
    <statement>
    ...</statement></statement></condition></code></pre>
<p dir="ltr">Eğer <code><condition></condition></code> doğruysa, program altında girintili ifadeleri çalıştıracaktır. İç ifadelerin girintisi Python'da <italic>gereklidir</italic> ve yanlış girinti yapmak sözdizimi hatasına veya buggy programına neden olur.</p>
<p dir="ltr">Aşağıda, bir değişkeni bir koşula göre yeniden atayan basit <code>if</code> bir ifade verilmiştir:</p>
<pre dir="ltr"><code>clothing = "shirt"

< 32:="" clothing="jacket"></code></pre>TODO: Sınav<h3 dir="ltr">Bileşik koşullular</h3>
<p dir="ltr">Koşullu bir deyim, diğer koşulları denetlemek ve farklı kod bloklarını yürütmek için herhangi bir sayıda <code>elif</code> deyim içerebilir. Diğer diller kullanır <code>else if</code>, ancak Python bunun çok uzun olduğuna karar verdi ve bunu <code>elif</code>. ♀️</p>
<p dir="ltr">İşte üç koşullu yol içeren bir şablon:</p>
<pre dir="ltr"><code><condition>:
    <statement>
    ...
elif <condition>:
    <statement>
    ...
elif <condition>:
    <statement>
    ...</statement></condition></statement></condition></statement></condition></code></pre>
<p dir="ltr">Aşağıda, önceki örneğin bir yol daha içeren bir uzantısı verilmiştir:</p>
<pre dir="ltr"><code>clothing = "shirt"

< 0:="" clothing="snowsuit" elif="" temperature="">< 32:="" clothing="jacket"></code></pre>
<p dir="ltr">Bir koşulluyu anladığımızdan emin olmanın bir yolu, program durumunun ve sonucun olası değerlerini gösteren bir tablo oluşturmaktır.</p>
<p dir="ltr">Mesela:</p>TÜMÜ: tablo<p dir="ltr">Sınır koşullarında neler olduğundan iki kat emin olmak iyi bir fikirdir - bazen fark edebilirsiniz ki, "uh oh! &gt;=, &gt; değil, kötüm!" dedim. Koşullu işlev kullanan bir işlev için testler yazarken, bu sınır koşullarını sınadığınızdan emin olun.</p>
<p dir="ltr">Son olarak, koşullu bir deyim, önceki koşullardan hiçbiri doğru değilse hangi kodun yürütülmesi gerektiğini belirtmek için bir <code>else</code> yan tümce içerebilir.</p>
<pre dir="ltr"><code><condition>:
    <statement>
    ...
elif <condition>:
    <statement>
    ...
else <condition>:
    <statement>
    ...</statement></condition></statement></condition></statement></condition></code></pre>
<p dir="ltr">İşte önceki örneği //<code>elif</code><code>else</code> kullanarak <code>if</code>yeniden yazmanın bir yolu:</p>
<pre dir="ltr"><code>< 0:="" clothing="snowsuit" elif="" temperature="">< 32:="" clothing="jacket" else:="" clothing="shirt"></code></pre>
<p dir="ltr">Bu kod, aşağıdaki tabloda gösterilenle aynı değerlerle <code>clothing</code> sonuçlanır, ancak daha net okunur.</p>
<p dir="ltr">Özetle, koşullu bir ifade:</p>
<ul dir="ltr"><li><p>her zaman bir <code>if</code> cümle ile başlar</p></li>
<li><p>0 veya daha fazla <code>elif</code> cümle içerebilir</p></li>
<li><p>isteğe bağlı olarak bir <code>else</code> cümle ile bitebilir</p></li></ul>
<h3 dir="ltr">İşlevlerde koşulluları kullanma</h3>
<p dir="ltr">Koşullu bir ifade, daha uzun bir işlevin yalnızca bir parçası olabilir veya işlevin tamamı olabilir. Giriş parametrelerini karşılaştırmak için koşullu kullanan bir işlev yazmak ve geçirilenlere göre değerleri döndürmek yaygındır.</p>
<p dir="ltr">Mesela:</p>
<pre dir="ltr"><code>def get_number_sign(num):
    < 0:="" sign="negative" elif="" num=""> 0:
        sign = "positive"
    else:
        sign = "neutral"
    return sign</code></pre>
<p dir="ltr">Bu işlevi şöyle adlandırırız:</p>
<pre dir="ltr"><code>get_number_sign(50)  # Returns: "positive"
get_number_sign(-1)  # Returns: "negative"
get_number_sign(0)   # Returns: "neutral"</code></pre>
<p dir="ltr">Ayrıca, koşulun her dalını bir geri dönüşle sonlandırabilir, yukarıdaki işlevi şu şekilde yeniden yazabiliriz:</p>
<pre dir="ltr"><code>def get_number_sign(num):
    < 0:="" return="" "negative"="" elif="" num=""> 0:
        return "positive"
    else:
        return "neutral"</code></pre>
<p dir="ltr">Bu, işlevin bu değeri döndürmekten başka bir şey yapmayacağını çok açık bir şekilde ortaya koyar, çünkü bir return deyimi bir işlevden hemen çıkar.</p>
<p dir="ltr">Bu işlevi yazmanın bir yolu daha var, koşullu olanı <code>else</code> bırakarak:</p>
<pre dir="ltr"><code>def get_number_sign(num):
    < 0:="" return="" "negative"="" elif="" num=""> 0:
        return "positive"
    return "neutral"</code></pre>
<p dir="ltr">Bu işlev 0'ı aldığında <code>num</code> , koşullu içindeki return deyimlerinden birini yürütmez, çünkü her iki koşul da doğru değildir. Devam eder, bir sonraki ifadenin bir return deyimi olduğunu keşfeder ve bunun yerine bu ifadeyi yürütür.</p>
<hr dir="ltr">
<p dir="ltr"> ♀️ ♂️ Bu makaledeki içerikle ilgili herhangi bir sorunuz varsa, Slack'teki #questions kanalına göndermeniz yeterlidir. Sorularınız olduğunda lütfen gönderin, size yardımcı olmak için buradayız!</p>